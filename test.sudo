Awesome! Now, we need to write tests for the `ExpressionsRepositoryImpl`:
```
import 'package:dartz/dartz.dart';
import 'package:injectable/injectable.dart';

import '../../../../core/clean_architecture/entity.dart';
import '../../../../core/data/failure_or_id_future.dart';
import '../../../../core/error/failure.dart';
import '../../../../core/utils/logger.dart';
import '../../domain/entities/expression.dart';
import '../../domain/repositories/expressions_repository.dart';
import '../datasources/indexed_db/expressions_indexed_db_data_source.dart';
import '../models/expression_mapper.dart';

@Injectable(as: Logger<ExpressionsRepositoryImpl>)
class ExpressionsRepositoryLogger extends Logger<ExpressionsRepositoryImpl> {}

@Injectable(as: ExpressionsRepository)
class ExpressionsRepositoryImpl extends ExpressionsRepository {
  final ExpressionsIndexedDbDataSource _expressionsLocalDataSource;
  final ExpressionMapper _expressionMapper;
  final Logger<ExpressionsRepositoryImpl> _logger;

  ExpressionsRepositoryImpl(
    this._expressionsLocalDataSource,
    this._expressionMapper,
    this._logger,
  );

  @override
  FailureOrIdsFuture saveExpressions(Iterable<Expression> expressions) async {
    try {
      var ids = List<Id>.empty(growable: true);
      for (var expression in expressions) {
        var id = await _expressionsLocalDataSource.putObject(
          _expressionMapper.fromExpression(expression),
        );
        ids.add(id);
      }

      return Right(ids);
    } catch (e) {
      _logger.logError('Failed to add expressions', e);
      return Left(LocalDataSourceFailure());
    }
  }

  @override
  ExpressionsOrFailureFuture getExpressions(Iterable<Id> ids) async {
    try {
      var expressionModels =
          await _expressionsLocalDataSource.getObjects(ids.toList());

      var expressions =
          expressionModels.map(_expressionMapper.toExpression).toList();

      return Right(expressions);
    } catch (e) {
      _logger.logError('Failed to get expressions with ids: $ids', e);
      return Left(LocalDataSourceFailure());
    }
  }
}
```

This time I have the class-under-test initialization and test already defined:
```
import 'package:flutter_test/flutter_test.dart';
import 'package:mascot/features/expressions/data/repositories/expressions_repository_impl.dart';

import '../../../../fixtures/test_context.dart';

void main() {
  late TestContext context;
  late ExpressionsRepositoryImpl repository;

  setUp(() {
    context = TestContext();
    repository = ExpressionsRepositoryImpl(
      context.mocks.expressionsLocalDataSource,
      context.data.expressionMapper,
      context.mocks.getLogger(),
    );
  });

  group('ExpressionsRepositoryImpl', () {
    group('saveExpressions', () {
      test(
        'should save expressions to data source',
        () async {},
      );

      test(
        'should return newly created expression ids when save is successful',
        () async {},
      );

      test(
        'should return LocalDataSourceFailure when exception occurs',
        () async {},
      );
    });

    group('getExpressions', () {
      test(
        'should return expressions from data source',
        () async {},
      );

      test(
        'should return LocalDataSourceFailure when exception occurs',
        () async {},
      );
    });
  });
}
```

You'll act as an expert in test automation to implement the defined tests.

For reference, here is what the `context.data` looks like:
```
import 'dart:typed_data';

import 'package:mascot/core/utils/constants.dart';
import 'package:mascot/features/expressions/data/models/expression_mapper.dart';
import 'package:mascot/features/expressions/domain/entities/expression.dart';
import 'package:mascot/features/mascot/data/models/mascot_mapper.dart';
import 'package:mascot/features/mascot/domain/entities/mascot.dart';
import 'package:mascot/features/mascot/presentation/bloc/create_mascot_bloc.dart';
import 'package:mascot/features/settings/data/models/settings_mapper.dart';
import 'package:mascot/features/settings/domain/entities/settings.dart';

import 'test_x_file.dart';

class TestData {
  TestXFile? _xfile;
  TestXFile get xfile => _xfile ??= TestXFile.fromData(
        Uint8List(5),
        name: 'test',
      );

  final Expression expression = Expression(
    id: 1,
    name: CreateMascotBloc.neutralExpressionName,
    description: CreateMascotBloc.neutralExpressionDescription,
    image: Uint8List(5),
  );
  final ExpressionMapperImpl expressionMapper = ExpressionMapperImpl();

  final List<Expression> expressions = [
    Expression(
      id: 1,
      name: CreateMascotBloc.neutralExpressionName,
      description: CreateMascotBloc.neutralExpressionDescription,
      image: Uint8List(5),
    ),
    Expression(
      id: 2,
      name: talkingExpressionName,
      description: CreateMascotBloc.talkingExpressionDescription,
      image: Uint8List(5),
    ),
  ];

  final Mascot mascot = Mascot(
    id: 1,
    name: 'test',
    expressions: {
      Expression(
        id: 1,
        name: CreateMascotBloc.neutralExpressionName,
        description: CreateMascotBloc.neutralExpressionDescription,
        image: Uint8List(5),
      ),
      Expression(
        id: 2,
        name: talkingExpressionName,
        description: CreateMascotBloc.talkingExpressionDescription,
        image: Uint8List(5),
      ),
    },
  );
  final MascotMapperImpl mascotMapper =
      MascotMapperImpl(ExpressionMapperImpl());

  final Settings settings = const Settings(favoriteMascotId: 1);
  final SettingsMapperImpl settingsMapper = SettingsMapperImpl();
}
```
