
Act as an expert Flutter Developer and an expert in Material UI language.
You will be provided relevant context.
You can ask for more context if necessary.
Update the code I provide based on a few requirements.
You can suggest new code if you need to.
Your modifications should be concise, but you should explain each step.
Place comments on their own lines.
You may ask to see more revelant code if necessary.

First prompt:

I have the following JS Interop Flutter code:
```
@JS()
library static_interop;

import 'package:injectable/injectable.dart';
import 'package:js/js.dart';
import 'package:universal_html/html.dart';

import 'analyser_node.dart';
import 'media_stream_audio_source_node.dart';

@JS()
@staticInterop
@anonymous
class AudioContextOptions {
  external factory AudioContextOptions({
    dynamic latencyHint = 'interactive',
    num sampleRate,
    dynamic sinkId,
  });
}

@JS('AudioContext')
@staticInterop
class JSAudioContext {
  external factory JSAudioContext([AudioContextOptions options]);
}

extension JSAudioContextExtension on JSAudioContext {
  external JSMediaStreamAudioSourceNode createMediaStreamSource(
    MediaStream stream,
  );

  external JSAnalyserNode createAnalyser();

  external void close();
  external void resume();
}

@lazySingleton
class AudioContext {
  final JSAudioContext _jsAudioContext;

  AudioContext() : _jsAudioContext = JSAudioContext()..resume();

  MediaStreamAudioSourceNode createMediaStreamSource(MediaStream stream) =>
      MediaStreamAudioSourceNode(
        _jsAudioContext.createMediaStreamSource(stream),
      );

  AnalyserNode createAnalyser() =>
      AnalyserNode(_jsAudioContext.createAnalyser());

  void close() => _jsAudioContext.close();

  @disposeMethod
  void dispose() => close();
}

@JS()
@staticInterop
@anonymous
class AudioNodeOptions {
  external factory AudioNodeOptions({
    int channelCount,
    String channelCountMode,
    String channelInterpretation,
  });
}

@JS('AudioNode')
@staticInterop
class JSAudioNode {
  external factory JSAudioNode([AudioNodeOptions options]);
}

extension JSAudioNodeExtension on JSAudioNode {
  external void connect(JSAudioNode destination);
  external void disconnect(JSAudioNode destination);
  external JSAudioNode get context;
}

class AudioNode {
  final JSAudioNode _jsAudioNode;

  AudioNode(this._jsAudioNode);

  void connect(AudioNode destination) =>
      _jsAudioNode.connect(destination._jsAudioNode);

  void disconnect(AudioNode destination) =>
      _jsAudioNode.disconnect(destination._jsAudioNode);

  AudioNode get context => AudioNode(_jsAudioNode.context);
}

@JS('AnalyserNode')
@staticInterop
class JSAnalyserNode extends JSAudioNode {
  external factory JSAnalyserNode();
}

extension JSAnalyserNodeExtension on JSAnalyserNode {
  external void getFloatTimeDomainData(Float32List array);
  external int get frequencyBinCount;
}

class AnalyserNode extends AudioNode {
  final JSAnalyserNode _jsAnalyzerNode;

  AnalyserNode(this._jsAnalyzerNode) : super(_jsAnalyzerNode);

  void getFloatTimeDomainData(Float32List array) =>
      _jsAnalyzerNode.getFloatTimeDomainData(array);

  int get frequencyBinCount => _jsAnalyzerNode.frequencyBinCount;
}

@JS('MediaStreamAudioSourceNode')
@staticInterop
class JSMediaStreamAudioSourceNode extends JSAudioNode {
  external factory JSMediaStreamAudioSourceNode();
}

extension JSMediaStreamAudioSourceNodeExtension
    on JSMediaStreamAudioSourceNode {
  external MediaStream get mediaStream;
}

class MediaStreamAudioSourceNode extends AudioNode {
  final JSMediaStreamAudioSourceNode _jsMediaStreamAudioSourceNode;

  MediaStreamAudioSourceNode(this._jsMediaStreamAudioSourceNode)
      : super(_jsMediaStreamAudioSourceNode);

  MediaStream get mediaStream => _jsMediaStreamAudioSourceNode.mediaStream;
}
```

And this class:
```
import 'dart:async';
import 'dart:typed_data';

import 'package:get_it/get_it.dart';
import 'package:injectable/injectable.dart';
import 'package:universal_html/html.dart' as html;

import '../../../../core/device/web/js_interop/web_audio/web_audio.dart';
import '../../../../core/extensions/extensions.dart';
import '../../../../core/utils/logger.dart';
import '../../domain/models/decibel_lufs.dart';
import '../microphone.dart';

@Injectable(as: Logger<WebMicrophone>)
class MascotMicrophoneLogger extends Logger<WebMicrophone> {}

@LazySingleton(as: Microphone)
class WebMicrophone implements Microphone, Disposable {
  final AudioContext _webAudio;
  final Logger<WebMicrophone> _logger;
  final StreamController<DecibelLufs> _volumeStreamController =
      StreamController.broadcast();

  html.MediaStream? _microphoneStream;
  AnalyserNode? _analyzer;
  MediaStreamAudioSourceNode? _source;

  WebMicrophone(this._webAudio, this._logger);

  @override
  Future<bool> hasPermission() async {
    await _setMicrophoneStream();
    return _microphoneStream != null;
  }

  @override
  Stream<DecibelLufs> get volumeStream {
    _startVolumeUpdates();
    return _volumeStreamController.stream;
  }

  Timer? _volumeUpdateTimer;
  void _startVolumeUpdates() async {
    if (_volumeUpdateTimer != null) {
      return; // Timer already started
    }

    final analyzer = await _getAnalyzer();
    final data = Float32List(analyzer.frequencyBinCount);

    _volumeUpdateTimer = Timer.periodic(
      const Duration(milliseconds: 17), // ~60fps
      (_) {
        // get the audio data from the analyzer
        analyzer.getFloatTimeDomainData(data);

        _volumeStreamController.add(DecibelLufs(data.loudness));
      },
    );
  }

  void _stopVolumeUpdates() {
    _volumeUpdateTimer?.cancel();
    _volumeUpdateTimer = null;
  }

  Future<void> _setMicrophoneStream({bool throwOnError = false}) async {
    try {
      _microphoneStream ??=
          await html.window.navigator.mediaDevices?.getUserMedia({
        'audio': true,
      });
    } catch (e) {
      var message = 'Error getting microphone stream:';
      if (e is html.DomException && e.name == 'NotAllowedError') {
        message = 'Microphone permission denied:';
      }

      _logger.logError(
        message,
        e,
      );

      if (throwOnError) rethrow;
    }

    if (throwOnError && _microphoneStream == null) {
      var e = Exception('Failed to get microphone stream');
      _logger.logError(e.toString(), e);
      throw e;
    }
  }

  Future<AnalyserNode> _getAnalyzer() async {
    if (_analyzer == null) {
      final source = await _getSource();
      _analyzer = _webAudio.createAnalyser();
      source.connect(_analyzer!);
    }

    return _analyzer!;
  }

  Future<MediaStreamAudioSourceNode> _getSource() async {
    await _setMicrophoneStream(throwOnError: true);

    return _source ??= _webAudio.createMediaStreamSource(_microphoneStream!);
  }

  @override
  FutureOr onDispose() {
    _stopVolumeUpdates();
    _volumeStreamController.close();
    _volumeUpdateTimer?.cancel();
  }
}
```

# Context

This is JS interop code that allows me to stream a microphone in Flutter on the web using the WebAudio API.
Elsewhere in the program, I pull data from the node on a timer (17 milliseconds) to calculate the volume of the
audio and display the volume on screen. I need to be able to do something similar for streaming from a camera.
The frames will be used in an image classifier model and streamed to the Flutter UI for a user to see.

At this time, you don't have knowledge of `@staticInterop`. So, here is the specification:

With package:js, we have historically had two different types of classes: plain @JS (those with just the @JS annotation) and @anonymous classes. Now, you can use a new one: @staticInterop.

These classes are different in that they do not allow instance members within the class itself. All such members need to go into an extension (hence “static”). Let’s look at an example:
```
@JS()
library static_interop;

import 'package:js/js.dart';

// Assumes there is a top-level `StaticInterop` class in a JS module.
@JS()
@staticInterop
class StaticInterop {
  external factory StaticInterop();
}

extension on StaticInterop {
  external int field;
  external int get getSet;
  external set getSet(int val);
  external int method();
}

void main() {
  var jsObj = StaticInterop();
  jsObj.field = 1;
  jsObj.method();
}
```
The external static extension members get lowered to JS naturally: jsObj.field becomes a property get of field in JS and jsObj.method() becomes a function invocation of method on jsObj.

In many ways, these classes are just like the plain @JS and @anonymous classes. Like with plain @JS classes, you can provide a value in @JS if you want the constructor to use a particular JS class e.g. @JS(‘module.MyJSClass’). You can also add @anonymous to @staticInterop classes if you want the factory constructor with named arguments in order to make an object literal e.g. external factory AnonymousStaticInterop({int? field1, int? field2}). Also like with plain @JS classes, you can’t inherit non-package:js classes. You should only inherit other @staticInterop classes for subtyping and inheriting extension methods. Lastly, you can freely cast JS objects to and from the three types of package:js classes.

What makes @staticInterop unique, however, is that you can use them to represent DOM objects as well as other JS objects, which you can’t with previous package:js classes. Historically, you’ve needed to use dart:html to interact with the DOM e.g. DivElement. Now, you can create your own abstraction for these objects instead of using the ones we provide in dart:html:
```
@JS()
library static_interop;

import 'dart:html' as html;

import 'package:js/js.dart';

@JS()
@staticInterop
class JSWindow {}

extension JSWindowExtension on JSWindow {
  external String get name;
  String get nameAllCaps => name.toUpperCase();
}

void main() {
  var jsWindow = html.window as JSWindow;
  print(jsWindow.name.toUpperCase() == jsWindow.nameAllCaps);
}
```

Note that you can have both external and non-external members in the extension.

Compared to non-@staticInterop package:js classes, @staticInterop classes:

    Are more performant
    Have better type guarantees
    Generate less code
    Allow non-external members
    Allow external extension members to be renamed using @JS() e.g. @JS('renamedField')

The only catch is that virtual/dynamic dispatch is disallowed. That means methods are resolved using only the static type of the object.

In general, it's advised to use @staticInterop wherever you can, as future JS interop will only target static dispatch.

# Requirements

Write the javascript interop code that will allow me to pull frames from a camera stream so that I can process the frame in Flutter/Dart.
